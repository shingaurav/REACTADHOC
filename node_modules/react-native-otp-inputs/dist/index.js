import React, { Component } from 'react';
import { Keyboard, Text, View, } from 'react-native';
import flatten from 'lodash.flatten';
import OtpInput from './OtpInput';
import defaultStyles from './defaultStyles';
const MINIMAL_INDEX = 0;
export default class OtpInputs extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            inputsArray: [],
            loading: false,
            otpCode: [],
        };
        this.inputs = [];
        this._handleAfterOtpAction = (otpCode, indexToFocus) => {
            const { handleChange, numberOfInputs } = this.props;
            handleChange && handleChange(otpCode.join(''));
            this.setState({ otpCode });
            if (indexToFocus === numberOfInputs) {
                return Keyboard.dismiss();
            }
            if (indexToFocus >= MINIMAL_INDEX && indexToFocus < numberOfInputs) {
                this._focusInput(indexToFocus);
            }
        };
        this._updateText = (event, index) => {
            let { text } = event.nativeEvent;
            const textLength = text.length;
            if (text) {
                const otpArray = this.state.otpCode;
                if (textLength > 2) {
                    const { numberOfInputs } = this.props;
                    otpArray[index] = textLength > numberOfInputs - index ? [text.slice(1)] : [text];
                    this._handleAfterOtpAction(flatten(otpArray.join('')).slice(0, numberOfInputs), textLength);
                }
                else {
                    otpArray[index] = text[text.length - 1];
                    this._handleAfterOtpAction(otpArray, index + 1);
                }
            }
        };
        this._handleBackspace = (event, index) => {
            if (event.nativeEvent.key === 'Backspace') {
                const { handleChange, numberOfInputs } = this.props;
                const otpCode = this.state.otpCode;
                otpCode[index] = '';
                handleChange && handleChange(otpCode.join(''));
                this.setState({ otpCode });
                if (index > MINIMAL_INDEX && index < numberOfInputs) {
                    this._focusInput(index - 1);
                }
            }
        };
        this._focusInput = (index) => {
            this.inputs[index].input.focus();
        };
        this._renderInputs = () => {
            const { autoCapitalize, clearTextOnFocus, errorMessage, focusedBorderColor, inputContainerStyles, inputStyles, inputTextErrorColor, keyboardType, numberOfInputs, secureTextEntry, selectTextOnFocus, unFocusedBorderColor, } = this.props;
            const { otpCode } = this.state;
            let inputArray = [];
            for (let index = MINIMAL_INDEX; index < numberOfInputs; index++) {
                inputArray[index] = (<OtpInput autoCapitalize={autoCapitalize} clearTextOnFocus={clearTextOnFocus} containerStyles={inputContainerStyles} error={!!errorMessage} focusedBorderColor={focusedBorderColor} handleBackspace={(event) => this._handleBackspace(event, index)} inputStyles={inputStyles} key={index} secureTextEntry={secureTextEntry} keyboardType={keyboardType} ref={input => (this.inputs[index] = input)} selectTextOnFocus={selectTextOnFocus} textErrorColor={inputTextErrorColor} unFocusedBorderColor={unFocusedBorderColor} updateText={(event) => this._updateText(event, index)} value={otpCode[index]}/>);
            }
            return inputArray.map(input => input);
        };
    }
    componentDidMount() {
        this._renderInputs();
    }
    render() {
        const { containerStyles, errorMessage, errorMessageContainerStyles, errorMessageTextStyles, inputsContainerStyles, } = this.props;
        return (<View style={[defaultStyles.container, containerStyles]}>
        {errorMessage && (<View style={[defaultStyles.errorMessageContainer, errorMessageContainerStyles]}>
            <Text testID="errorText" style={errorMessageTextStyles}>
              {errorMessage}
            </Text>
          </View>)}
        <View style={[defaultStyles.inputsContainer, inputsContainerStyles]}>
          {this._renderInputs()}
        </View>
      </View>);
    }
}
OtpInputs.defaultProps = {
    autoCapitalize: 'none',
    clearTextOnFocus: false,
    focusedBorderColor: '#0000ff',
    handleChange: console.log,
    inputTextErrorColor: '#ff0000',
    keyboardType: 'phone-pad',
    numberOfInputs: 4,
    secureTextEntry: false,
    selectTextOnFocus: true,
    unFocusedBorderColor: 'transparent',
};
//# sourceMappingURL=index.js.map